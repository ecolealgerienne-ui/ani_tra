â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                        â•‘
â•‘        ğŸ“‹ PHASE 1B DUPPLICATION - SPECS COMPLÃˆTES 11 ENTITÃ‰S          â•‘
â•‘                                                                        â•‘
â•‘              Document: SPECIFICATIONS & TEMPLATES                     â•‘
â•‘              Status: READY TO CODE                                    â•‘
â•‘              Date: 2025-11-11                                         â•‘
â•‘                                                                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
0. OVERVIEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OBJECTIF:
  Dupliquer le pattern Animals (B1+B2+B3+B4+A1-A6) aux 11 entitÃ©s restantes

SCOPE:
  âœ… 11 entitÃ©s (voir section 1)
  âœ… 3 fichiers par entitÃ© (Table, DAO, Repository)
  âœ… Patterns: FK + Indexes + Multi-tenancy + Logging
  âœ… Multi-farm: 100% complÃ©tÃ© (DAO level)

SUCCESS CRITERIA:
  âœ… Tous les fichiers compilent (flutter analyze = 0 erreurs)
  âœ… Build runner passe sans erreurs
  âœ… flutter run sans crash
  âœ… Multi-tenancy sÃ©curisÃ© (farmId obligatoire)

TIMELINE:
  Tier 1 (4 entitÃ©s): 2-3 heures
  Tier 2 (4 entitÃ©s): 2-3 heures
  Tier 3 (3 entitÃ©s): 1-2 heures
  TOTAL: 5-8 heures

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. LES 11 ENTITÃ‰S Ã€ TRAITER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIER 1 - CORE (Ã€ FAIRE EN PRIORITÃ‰ - 2-3h):
  Priority 1: TREATMENTS
  Priority 2: VACCINATIONS
  Priority 3: WEIGHTS
  Priority 4: MOVEMENTS

TIER 2 - SECONDARY (AprÃ¨s Tier 1 - 2-3h):
  Priority 5: BATCHES
  Priority 6: LOTS
  Priority 7: CAMPAIGNS
  Priority 8: MEDICAL_PRODUCTS

TIER 3 - REFERENCE (AprÃ¨s Tier 2 - 1-2h):
  Priority 9: BREEDS
  Priority 10: BREEDING
  Priority 11: DOCUMENTS

DÃ‰PENDANCES:
  BREEDING â†’ dÃ©pend de ANIMALS + BREEDS
  LOTS â†’ dÃ©pend de BATCHES
  TREATMENTS â†’ peut Ãªtre indÃ©pendant
  VACCINATIONS â†’ peut Ãªtre indÃ©pendant
  WEIGHTS â†’ peut Ãªtre indÃ©pendant
  MOVEMENTS â†’ peut Ãªtre indÃ©pendant

RECOMMANDATION ORDRE:
  1. Faire TIER 1 au complet (foundation)
  2. Puis TIER 2 (dependencies resolved)
  3. Puis TIER 3 (rÃ©fÃ©rences)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2. FICHIERS Ã€ MODIFIER PAR ENTITÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

FORMAT FICHIER NAMES:
  Table:      {entity}_table.dart           â†’ lib/drift/tables/
  DAO:        {entity}_dao.dart             â†’ lib/drift/daos/
  Repository: {entity}_repository.dart      â†’ lib/repositories/
  Provider:   {entity}_provider.dart        â†’ lib/providers/ (MODIFIER SI EXISTE)
  Strings:    app_strings.dart              â†’ lib/i18n/ (AJOUTER CLÃ‰S)

EXEMPLE TREATMENTS:
  âœ… treatments_table.dart        (CRÃ‰ER/MODIFIER)
  âœ… treatment_dao.dart           (CRÃ‰ER/MODIFIER)
  âœ… treatment_repository.dart    (CRÃ‰ER/MODIFIER)
  âœ… treatment_provider.dart      (MODIFIER existant - ajouter logging)
  âœ… app_strings.dart             (AJOUTER clÃ©s si nouvelles)

POUR CHAQUE ENTITÃ‰ - FICHIERS Ã€ TRAITER:

TREATMENTS:
  â”œâ”€ lib/drift/tables/treatments_table.dart (crÃ©er/modifier)
  â”œâ”€ lib/drift/daos/treatment_dao.dart (crÃ©er/modifier)
  â”œâ”€ lib/repositories/treatment_repository.dart (crÃ©er/modifier)
  â””â”€ lib/providers/treatment_provider.dart (modifier - logging)

VACCINATIONS:
  â”œâ”€ lib/drift/tables/vaccinations_table.dart
  â”œâ”€ lib/drift/daos/vaccination_dao.dart
  â”œâ”€ lib/repositories/vaccination_repository.dart
  â””â”€ lib/providers/vaccination_provider.dart

WEIGHTS:
  â”œâ”€ lib/drift/tables/weights_table.dart
  â”œâ”€ lib/drift/daos/weight_dao.dart
  â”œâ”€ lib/repositories/weight_repository.dart
  â””â”€ lib/providers/weight_provider.dart

MOVEMENTS:
  â”œâ”€ lib/drift/tables/movements_table.dart
  â”œâ”€ lib/drift/daos/movement_dao.dart
  â”œâ”€ lib/repositories/movement_repository.dart
  â””â”€ lib/providers/movement_provider.dart

(idem pour BATCHES, LOTS, CAMPAIGNS, MEDICAL_PRODUCTS, BREEDS, BREEDING, DOCUMENTS)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3. TEMPLATE GÃ‰NÃ‰RIQUE - TABLE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRINCIPE:
  - Copy-paste cette template
  - Remplacer [ENTITY_UPPER] par ton entitÃ© en MAJUSCULE
  - Remplacer [entity] par ton entitÃ© en minuscule
  - Adapter les colonnes Ã  l'entitÃ© rÃ©elle
  - Garder TOUJOURS: id, farmId, synced, timestamps, deletedAt

STRUCTURE TEMPLATE:

```dart
// lib/drift/tables/[entity]_table.dart
import 'package:drift/drift.dart';

class [ENTITY_UPPER]sTable extends Table {
  @override
  String get tableName => '[entity]s';

  // ==================== OBLIGATOIRES ====================
  
  // Primary key
  TextColumn get id => text()();

  // Multi-tenancy (TOUJOURS prÃ©sent)
  TextColumn get farmId => text().named('farm_id')();

  // [ENTITY] - specific columns
  // Ã€ adapter selon l'entitÃ©
  TextColumn get name => text()();
  TextColumn get description => text().nullable().named('description')();
  DateTimeColumn get date => dateTime().nullable().named('date')();
  TextColumn get type => text().nullable().named('type')();
  // ... autres colonnes spÃ©cifiques ...

  // Sync fields (Phase 2 ready) - TOUJOURS prÃ©sent
  BoolColumn get synced => boolean().withDefault(const Constant(false))();
  DateTimeColumn get lastSyncedAt =>
      dateTime().nullable().named('last_synced_at')();
  TextColumn get serverVersion => text().nullable().named('server_version')();

  // Soft-delete (audit trail) - TOUJOURS prÃ©sent
  DateTimeColumn get deletedAt => dateTime().nullable().named('deleted_at')();

  // Timestamps - TOUJOURS prÃ©sent
  DateTimeColumn get createdAt => dateTime().named('created_at')();
  DateTimeColumn get updatedAt => dateTime().named('updated_at')();

  @override
  Set<Column> get primaryKey => {id};

  // ==================== B2: FK + INDEXES ====================
  @override
  List<String> get customConstraints => [
    'FOREIGN KEY (farm_id) REFERENCES farms(id) ON DELETE CASCADE',
    'CREATE INDEX IF NOT EXISTS idx_[entity]s_farm_id ON [entity]s(farm_id)',
    'CREATE INDEX IF NOT EXISTS idx_[entity]s_farm_created ON [entity]s(farm_id, created_at DESC)',
    'CREATE INDEX IF NOT EXISTS idx_[entity]s_deleted_at ON [entity]s(deleted_at)',
  ];
}
```

IMPORTANT:
  âœ… @override List<String> get customConstraints (PAS customStatements!)
  âœ… farmId TOUJOURS prÃ©sent
  âœ… FK TOUJOURS prÃ©sent
  âœ… Sync fields TOUJOURS prÃ©sents
  âœ… Soft-delete TOUJOURS prÃ©sent
  âœ… 3 indexes MINIMUM (farm_id, farm+date, deleted_at)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4. TEMPLATE GÃ‰NÃ‰RIQUE - DAO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STRUCTURE TEMPLATE:

```dart
// lib/drift/daos/[entity]_dao.dart
import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/[entity]_table.dart';

part '[entity]_dao.g.dart';

@DriftAccessor(tables: [[ENTITY_UPPER]sTable])
class [ENTITY_UPPER]Dao extends DatabaseAccessor<AppDatabase> with _$[ENTITY_UPPER]DaoMixin {
  [ENTITY_UPPER]Dao(super.db);

  // ==================== MÃ‰THODES OBLIGATOIRES ====================

  /// 1. findByFarmId - TOUJOURS filtrer par farmId
  Future<List<[ENTITY_UPPER]sTableData>> findByFarmId(String farmId) {
    return (select([entity]sTable)
          ..where((t) => t.farmId.equals(farmId))
          ..where((t) => t.deletedAt.isNull()))
        .get();
  }

  /// 2. findById - SÃ©curitÃ© farmId
  Future<[ENTITY_UPPER]sTableData?> findById(String id, String farmId) {
    return (select([entity]sTable)
          ..where((t) => t.id.equals(id))
          ..where((t) => t.farmId.equals(farmId))
          ..where((t) => t.deletedAt.isNull()))
        .getSingleOrNull();
  }

  /// 3. insert
  Future<int> insertItem([ENTITY_UPPER]sTableCompanion item) {
    return into([entity]sTable).insert(item);
  }

  /// 4. update - B1 FIX: farmId MANDATORY
  Future<int> updateItem([ENTITY_UPPER]sTableCompanion item, String farmId) {
    return (update([entity]sTable)
          ..where((t) => t.id.equals(item.id.value))
          ..where((t) => t.farmId.equals(farmId)))
        .write(item);  // âœ… .write() PAS .replace()
  }

  /// 5. softDelete
  Future<int> softDelete(String id, String farmId) {
    return (update([entity]sTable)
          ..where((t) => t.id.equals(id))
          ..where((t) => t.farmId.equals(farmId)))
        .write([ENTITY_UPPER]sTableCompanion(
      deletedAt: Value(DateTime.now()),
      updatedAt: Value(DateTime.now()),
    ));
  }

  /// 6. getUnsynced - Phase 2 ready
  Future<List<[ENTITY_UPPER]sTableData>> getUnsynced(String farmId) {
    return (select([entity]sTable)
          ..where((t) => t.farmId.equals(farmId))
          ..where((t) => t.synced.equals(false))
          ..where((t) => t.deletedAt.isNull()))
        .get();
  }

  /// 7. markSynced - Phase 2 ready
  Future<int> markSynced(String id, String farmId) {
    return (update([entity]sTable)
          ..where((t) => t.id.equals(id))
          ..where((t) => t.farmId.equals(farmId)))
        .write([ENTITY_UPPER]sTableCompanion(
      synced: const Value(true),
      lastSyncedAt: Value(DateTime.now()),
      updatedAt: Value(DateTime.now()),
    ));
  }

  // ==================== B3: Compter optimisÃ© ====================
  Future<int> countByFarmId(String farmId) async {
    final count = countAll();
    final query = selectOnly([entity]sTable)
      ..addColumns([count])
      ..where([entity]sTable.farmId.equals(farmId))
      ..where([entity]sTable.deletedAt.isNull());

    final result = await query.getSingle();
    return result.read(count) ?? 0;
  }
}
```

IMPORTANT:
  âœ… part '[entity]_dao.g.dart' (OBLIGATOIRE)
  âœ… @DriftAccessor(tables: [[ENTITY_UPPER]sTable])
  âœ… Toutes les queries: .where(...farmId) + .where(...deletedAt)
  âœ… updateItem: .write() PAS .replace()
  âœ… Future<int> updateItem (PAS Future<bool>)
  âœ… countByFarmId avec selectOnly (pas full table scan)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5. TEMPLATE GÃ‰NÃ‰RIQUE - REPOSITORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STRUCTURE TEMPLATE:

```dart
// lib/repositories/[entity]_repository.dart
import 'dart:convert';
import 'package:drift/drift.dart';
import '../drift/database.dart';
import '../models/[entity].dart';

class [ENTITY_UPPER]Repository {
  final AppDatabase _db;

  [ENTITY_UPPER]Repository(this._db);

  // ==================== MÃ‰THODES OBLIGATOIRES ====================

  /// 1. getAll - Liste par farmId
  Future<List<[ENTITY_UPPER]>> getAll(String farmId) async {
    final items = await _db.[entity]Dao.findByFarmId(farmId);
    return items.map((data) => _mapToModel(data)).toList();
  }

  /// 2. getById - SÃ©curitÃ© farmId
  Future<[ENTITY_UPPER]?> getById(String id, String farmId) async {
    final item = await _db.[entity]Dao.findById(id, farmId);
    if (item == null) return null;

    if (item.farmId != farmId) {
      throw Exception('Farm ID mismatch - Security violation');
    }

    return _mapToModel(item);
  }

  /// 3. create - B4: avec logging
  Future<void> create([ENTITY_UPPER] item, String farmId) async {
    final companion = _mapToCompanion(item, farmId);
    await _db.[entity]Dao.insertItem(companion);
    debugPrint('âœ… [ENTITY_UPPER] crÃ©Ã©: ${item.id} dans farm $farmId');
  }

  /// 4. update - B1 FIX: Pass farmId
  Future<void> update([ENTITY_UPPER] item, String farmId) async {
    final existing = await _db.[entity]Dao.findById(item.id, farmId);
    if (existing == null || existing.farmId != farmId) {
      throw Exception('[ENTITY_UPPER] not found or farm mismatch');
    }

    final companion = _mapToCompanion(item, farmId);
    final result = await _db.[entity]Dao.updateItem(companion, farmId);
    if (result == 0) {
      throw Exception('[ENTITY_UPPER] update failed - no rows affected');
    }
    debugPrint('âœ… [ENTITY_UPPER] mis Ã  jour: ${item.id} dans farm $farmId');
  }

  /// 5. delete - Soft-delete
  Future<void> delete(String id, String farmId) async {
    await _db.[entity]Dao.softDelete(id, farmId);
    debugPrint('âœ… [ENTITY_UPPER] supprimÃ© (soft): $id dans farm $farmId');
  }

  /// 6. getUnsynced - Phase 2 ready
  Future<List<[ENTITY_UPPER]>> getUnsynced(String farmId) async {
    final items = await _db.[entity]Dao.getUnsynced(farmId);
    return items.map((data) => _mapToModel(data)).toList();
  }

  // ==================== B3: Compter ====================
  Future<int> count(String farmId) async {
    return await _db.[entity]Dao.countByFarmId(farmId);
  }

  // ==================== MAPPERS ====================

  /// Mapper DB â†’ Model
  [ENTITY_UPPER] _mapToModel([ENTITY_UPPER]sTableData data) {
    return [ENTITY_UPPER](
      id: data.id,
      farmId: data.farmId,
      // Adapter selon colonnes rÃ©elles de l'entitÃ©
      name: data.name,
      description: data.description,
      date: data.date,
      type: data.type,
      // ...
      synced: data.synced,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt,
      lastSyncedAt: data.lastSyncedAt,
      serverVersion: data.serverVersion,
    );
  }

  /// Mapper Model â†’ DB Companion
  [ENTITY_UPPER]sTableCompanion _mapToCompanion([ENTITY_UPPER] item, String farmId) {
    return [ENTITY_UPPER]sTableCompanion(
      id: Value(item.id),
      farmId: Value(farmId),
      // Adapter selon colonnes rÃ©elles
      name: Value(item.name),
      description: Value(item.description),
      date: Value(item.date),
      type: Value(item.type),
      // ...
      synced: Value(item.synced),
      createdAt: Value(item.createdAt),
      updatedAt: Value(item.updatedAt),
      lastSyncedAt: Value(item.lastSyncedAt),
      serverVersion: Value(item.serverVersion),
      deletedAt: const Value.absent(),
    );
  }
}
```

IMPORTANT:
  âœ… Tous les appels incluent farmId parameter
  âœ… Loggers: debugPrint() pour chaque opÃ©ration
  âœ… Mappers adaptÃ©s aux colonnes rÃ©elles
  âœ… Security checks au niveau repository
  âœ… Future<int> updateItem: vÃ©rifier result > 0

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6. PIÃˆGES Ã€ Ã‰VITER (BasÃ© ERREURS ANIMALS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PIÃˆGE #1: customConstraints Type âŒ
  âŒ FAUX: String get customConstraints => 'FK...';
  âœ… CORRECT: List<String> get customConstraints => ['FK...', 'INDEX...'];
  
  FIX: Toujours List<String>, jamais String!

---

PIÃˆGE #2: customStatements n'existe pas âŒ
  âŒ FAUX: List<String> get customStatements => [...];
  âœ… CORRECT: Mets les indexes dans customConstraints!
  
  FIX: Drift 2.29+ n'a que customConstraints, pas customStatements

---

PIÃˆGE #3: Multi-ligne expressions âŒ
  âŒ FAUX:
    return DateTime.now().difference(_lastRefreshTime!).inMinutes <
        _cacheTTL.inMinutes;
  
  âœ… CORRECT:
    return DateTime.now().difference(_lastRefreshTime!).inMinutes < _cacheTTL.inMinutes;
  
  FIX: Garder expressions sur UNE SEULE LIGNE

---

PIÃˆGE #4: .replace() + .where() âŒ
  âŒ FAUX:
    return (update(table)
          ..where((t) => t.id.equals(id)))
        .replace(companion);
  
  âœ… CORRECT:
    return (update(table)
          ..where((t) => t.id.equals(id))
          ..where((t) => t.farmId.equals(farmId)))
        .write(companion);
  
  FIX: Utiliser .write() quand tu as .where(), pas .replace()

---

PIÃˆGE #5: Type retour updateItem âŒ
  âŒ FAUX: Future<bool> updateItem(...) { return .write(...); }
  âœ… CORRECT: Future<int> updateItem(...) { return .write(...); }
  
  FIX: .write() retourne Future<int> (nombre de lignes), pas bool

---

PIÃˆGE #6: Oublier farmId parameter âŒ
  âŒ FAUX: await updateItem(companion);
  âœ… CORRECT: await updateItem(companion, farmId);
  
  FIX: farmId TOUJOURS obligatoire! C'est la sÃ©curitÃ© multi-tenancy

---

PIÃˆGE #7: Oublier imports âŒ
  âŒ FAUX: Pas d'import AppLocalizations, pas de import 'models/xxx'
  âœ… CORRECT: Importer AVANT d'utiliser
  
  Imports obligatoires pour DAO:
    import 'package:drift/drift.dart';
    import '../database.dart';
    import '../tables/[entity]_table.dart';
    part '[entity]_dao.g.dart';

---

PIÃˆGE #8: Soft-delete oubliÃ© âŒ
  âŒ FAUX: Pas de ..where((t) => t.deletedAt.isNull()) dans les queries
  âœ… CORRECT: TOUJOURS filtrer deletedAt dans les queries
  
  Chaque query doit avoir:
    ..where((t) => t.deletedAt.isNull())

---

PIÃˆGE #9: Pas de FK constraint âŒ
  âŒ FAUX: Pas de FOREIGN KEY dans customConstraints
  âœ… CORRECT: TOUJOURS avoir FK farm_id â†’ farms(id)
  
  customConstraints DOIT contenir:
    'FOREIGN KEY (farm_id) REFERENCES farms(id) ON DELETE CASCADE'

---

PIÃˆGE #10: Index strategy mauvaise âŒ
  âŒ FAUX: Pas d'indexes, ou juste 1 index
  âœ… CORRECT: Minimum 3 indexes (farm_id, farm+date, deleted_at)
  
  Indexes obligatoires:
    - idx_[entity]s_farm_id: Toutes les queries filtrent farm_id
    - idx_[entity]s_farm_created: Tri par crÃ©ation courant
    - idx_[entity]s_deleted_at: Soft-delete check

---

PIÃˆGE #11: @override oubliÃ©e âŒ
  âŒ FAUX: List<String> get customConstraints => [...];
  âœ… CORRECT: @override List<String> get customConstraints => [...];
  
  FIX: Toujours @override sur les getters qui override Table

---

PIÃˆGE #12: part directive oubliÃ©e âŒ
  âŒ FAUX: Pas de part '[entity]_dao.g.dart';
  âœ… CORRECT: part '[entity]_dao.g.dart'; (PREMIÃˆRE ligne aprÃ¨s imports)
  
  FIX: C'est la gÃ©nÃ©ration Drift. Sans Ã§a, build_runner crash

---

PIÃˆGE #13: Oublier .g.dart generation âŒ
  âŒ FAUX: flutter analyze sans build_runner
  âœ… CORRECT: flutter pub run build_runner build --delete-conflicting-outputs
  
  FIX: Ã€ faire aprÃ¨s chaque modification DAO/Table

---

PIÃˆGE #14: debugPrint vs print âŒ
  âŒ FAUX: debugPrint('text') ou print sans import
  âœ… CORRECT: debugPrint('âœ… Message') avec import flutter/foundation.dart
  
  FIX: Import obligatoire:
    import 'package:flutter/foundation.dart';

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
7. CHECKLIST PAR ENTITÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

AVANT DE CODER:
  [ ] Lire document spÃ©cifications (ce fichier)
  [ ] Identifier colonnes rÃ©elles de l'entitÃ©
  [ ] VÃ©rifier dÃ©pendances (ex: Lots dÃ©pend de Batches)
  [ ] Checker si ForeignKey vers autre table nÃ©cessaire
  [ ] Avoir le model .dart prÃªt (sinon copier Animal comme template)

CODING - TABLE:
  [ ] Fichier crÃ©Ã©: lib/drift/tables/[entity]_table.dart
  [ ] Class extends Table correctement nommÃ©e
  [ ] Colonnes: id, farmId, [specific], synced, timestamps, deletedAt
  [ ] @override primaryKey = {id}
  [ ] @override customConstraints avec FK + 3 indexes
  [ ] Pas de @override customStatements (n'existe pas!)
  [ ] Imports corrects

CODING - DAO:
  [ ] Fichier crÃ©Ã©: lib/drift/daos/[entity]_dao.dart
  [ ] part '[entity]_dao.g.dart' ligne 1 aprÃ¨s imports
  [ ] @DriftAccessor(tables: [[ENTITY]sTable])
  [ ] findByFarmId, findById, insertItem, updateItem, softDelete
  [ ] Toutes les queries: where farmId + where deletedAt
  [ ] updateItem: Future<int>, .write() PAS .replace()
  [ ] countByFarmId avec selectOnly
  [ ] Imports corrects

CODING - REPOSITORY:
  [ ] Fichier crÃ©Ã©: lib/repositories/[entity]_repository.dart
  [ ] getAll, getById, create, update, delete, getUnsynced, count
  [ ] Tous les appels: await ..._dao.method(id, farmId)
  [ ] Logging: debugPrint() Ã  chaque opÃ©ration
  [ ] Mappers: _mapToModel() et _mapToCompanion()
  [ ] Mappers adaptÃ©s aux colonnes rÃ©elles
  [ ] updateItem check: if (result == 0) throw Exception
  [ ] Import: debugPrint from 'package:flutter/foundation.dart'

TESTING - COMPILATION:
  [ ] flutter pub run build_runner build --delete-conflicting-outputs
  [ ] Pas d'erreur "Could not resolve annotation"
  [ ] Pas d'erreur "Failed assertion"
  [ ] Pas d'erreur de type
  [ ] flutter analyze = 0 erreurs

TESTING - RUNTIME:
  [ ] flutter run
  [ ] App dÃ©marre
  [ ] Pas de crash
  [ ] Si UI implÃ©mentÃ©e: CRUD fonctionne (add/update/delete)
  [ ] Logs affichent correctement

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8. TIMELINE & STRATÃ‰GIE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STRATÃ‰GIE BUILD_RUNNER:

OPTION A: Build une fois par entitÃ© (Safe)
  - Faire EntitÃ© 1 complet (Table + DAO + Repository)
  - Build runner
  - Tester compilation
  - Puis EntitÃ© 2
  TIMING: 30-40 min par entitÃ©
  RISQUE: Bas (isolÃ©)

OPTION B: Faire tous TIER 1, puis 1 build_runner (Fast)
  - Faire EntitÃ© 1 Table + DAO + Repo
  - Faire EntitÃ© 2 Table + DAO + Repo
  - Faire EntitÃ© 3 Table + DAO + Repo
  - Faire EntitÃ© 4 Table + DAO + Repo
  - Build runner UNE FOIS
  - Tester compilation
  TIMING: 20 min pour code + 3-5 min build_runner
  RISQUE: Moyen (erreurs difficiles Ã  isoler)

OPTION C: Hybride (RecommandÃ©)
  - Faire EntitÃ© 1 complet
  - Build runner
  - Faire EntitÃ© 2 + 3 code
  - Build runner
  - Faire EntitÃ© 4 + Repository des premiÃ¨res
  - Build runner final
  TIMING: 4-5 heures total
  RISQUE: Bas, efficace

RECOMMANDATION: Faire OPTION C

---

TIMELINE DÃ‰TAILLÃ‰E:

TIER 1 (2.5-3h):

  EntitÃ© 1: TREATMENTS
    - Coder: 20 min (Table + DAO + Repo)
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 2: VACCINATIONS
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 3: WEIGHTS
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 4: MOVEMENTS
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  PAUSE (15 min) â˜•

  Total TIER 1: 2h 15 min (avec pause)

---

TIER 2 (2.5-3h):

  EntitÃ© 5: BATCHES
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 6: LOTS (dÃ©pend Batches)
    - Coder: 20 min (+ FK vers Batches)
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 7: CAMPAIGNS
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 8: MEDICAL_PRODUCTS
    - Coder: 20 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  PAUSE (15 min) â˜•

  Total TIER 2: 2h 15 min (avec pause)

---

TIER 3 (1-1.5h):

  EntitÃ© 9: BREEDS
    - Coder: 15 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 19 min

  EntitÃ© 10: BREEDING (dÃ©pend Animals + Breeds)
    - Coder: 20 min (+ FK vers Breeds + Animals)
    - Build: 2 min
    - Test: 2 min
    Subtotal: 24 min

  EntitÃ© 11: DOCUMENTS
    - Coder: 15 min
    - Build: 2 min
    - Test: 2 min
    Subtotal: 19 min

  Total TIER 3: 1h 2 min

---

GRAND TOTAL:
  Tier 1: 2h 15 min
  Tier 2: 2h 15 min
  Tier 3: 1h 02 min
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  TOTAL: ~5h 32 min

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
9. COMMANDES POWERSHELL ESSENTIELLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BUILD RUNNER (Ã€ faire aprÃ¨s chaque batch d'entitÃ©s):
```powershell
flutter pub run build_runner build --delete-conflicting-outputs
```

SI BUILD_RUNNER HANG/TIMEOUT:
```powershell
flutter pub run build_runner clean
flutter pub run build_runner build --delete-conflicting-outputs
```

SI ERREUR "Could not resolve annotation":
```powershell
flutter clean
rm -r -Force .dart_tool, build
flutter pub get
flutter pub run build_runner build --delete-conflicting-outputs
```

ANALYSER FICHIER SPÃ‰CIFIQUE:
```powershell
flutter analyze lib/drift/daos/[entity]_dao.dart
flutter analyze lib/repositories/[entity]_repository.dart
flutter analyze lib/drift/tables/[entity]_table.dart
```

ANALYSER TOUT:
```powershell
flutter analyze
```

LANCER APP:
```powershell
flutter run
```

LANCER EN VERBOSE (pour debug):
```powershell
flutter run -v
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
10. ADAPTATION TEMPLATES PAR ENTITÃ‰
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

QUAND ADAPTER LA TEMPLATE:

1. COLONNES SPÃ‰CIFIQUES
   - Animals: birthDate, sex, motherId, etc.
   - Treatments: animalId, productId, startDate, endDate, etc.
   - Vaccinations: animalId, vaccineId, date, nextDate, etc.
   - Weights: animalId, weight, date, notes, etc.
   - Movements: fromLotId, toLotId, date, reason, etc.
   
   Ã€ FAIRE: Adapter les colonnes dans Table, DAO (select/where) et Repo (mappers)

2. FOREIGN KEYS SUPPLÃ‰MENTAIRES
   - Lots: FOREIGN KEY (batch_id) REFERENCES batches(id)
   - Breeding: FOREIGN KEY (female_id) REFERENCES animals(id)
   - Breeding: FOREIGN KEY (male_id) REFERENCES animals(id)
   
   Ã€ FAIRE: Ajouter dans customConstraints

3. INDEXES SUPPLÃ‰MENTAIRES
   - Si queries frÃ©quentes sur colonne X: ADD idx_[entity]_X
   - Si queries sur X + Y: ADD idx_[entity]_X_Y
   
   Ã€ FAIRE: Ajouter dans customConstraints

4. LOGIC MÃ‰TIER
   - Si soft delete logic diffÃ©rente: adapter updateItem
   - Si query complexe: ajouter mÃ©thodes custom dans DAO
   
   Ã€ FAIRE: Adapter findXxx() methods au besoin

EXEMPLE ADAPTATION - LOTS:

Table change:
```dart
// Ajouter:
TextColumn get batchId => text().named('batch_id')();

// customConstraints ajouter FK:
'FOREIGN KEY (batch_id) REFERENCES batches(id)',
```

DAO change:
```dart
// Ajouter mÃ©thode:
Future<List<LotsTableData>> findByBatchId(String batchId, String farmId) {
  return (select(lotsTable)
        ..where((t) => t.batchId.equals(batchId))
        ..where((t) => t.farmId.equals(farmId))
        ..where((t) => t.deletedAt.isNull()))
      .get();
}
```

Repository change:
```dart
// Ajouter mÃ©thode:
Future<List<Lot>> findByBatchId(String batchId, String farmId) async {
  final items = await _db.lotDao.findByBatchId(batchId, farmId);
  return items.map((data) => _mapToModel(data)).toList();
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
11. QUICK REFERENCE - PATTERNS DRIFT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PATTERN: Simple Query
```dart
Future<List<XyzTableData>> findByFarmId(String farmId) {
  return (select(xyzTable)
        ..where((t) => t.farmId.equals(farmId))
        ..where((t) => t.deletedAt.isNull()))
      .get();
}
```

PATTERN: Single Item
```dart
Future<XyzTableData?> findById(String id, String farmId) {
  return (select(xyzTable)
        ..where((t) => t.id.equals(id))
        ..where((t) => t.farmId.equals(farmId))
        ..where((t) => t.deletedAt.isNull()))
      .getSingleOrNull();
}
```

PATTERN: Insert
```dart
Future<int> insertItem(XyzTableCompanion item) {
  return into(xyzTable).insert(item);
}
```

PATTERN: Update avec WHERE
```dart
Future<int> updateItem(XyzTableCompanion item, String farmId) {
  return (update(xyzTable)
        ..where((t) => t.id.equals(item.id.value))
        ..where((t) => t.farmId.equals(farmId)))
      .write(item);  // âœ… .write() PAS .replace()
}
```

PATTERN: Soft Delete
```dart
Future<int> softDelete(String id, String farmId) {
  return (update(xyzTable)
        ..where((t) => t.id.equals(id))
        ..where((t) => t.farmId.equals(farmId)))
      .write(XyzTableCompanion(
        deletedAt: Value(DateTime.now()),
        updatedAt: Value(DateTime.now()),
      ));
}
```

PATTERN: Count
```dart
Future<int> countByFarmId(String farmId) async {
  final count = countAll();
  final query = selectOnly(xyzTable)
    ..addColumns([count])
    ..where(xyzTable.farmId.equals(farmId))
    ..where(xyzTable.deletedAt.isNull());

  final result = await query.getSingle();
  return result.read(count) ?? 0;
}
```

PATTERN: Mapper DB â†’ Model
```dart
Model _mapToModel(XyzTableData data) {
  return Model(
    id: data.id,
    farmId: data.farmId,
    name: data.name,
    createdAt: data.createdAt,
    updatedAt: data.updatedAt,
    synced: data.synced,
  );
}
```

PATTERN: Mapper Model â†’ Companion
```dart
XyzTableCompanion _mapToCompanion(Model item, String farmId) {
  return XyzTableCompanion(
    id: Value(item.id),
    farmId: Value(farmId),
    name: Value(item.name),
    createdAt: Value(item.createdAt),
    updatedAt: Value(item.updatedAt),
    synced: Value(item.synced),
    deletedAt: const Value.absent(),
  );
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
12. MULTI-TENANCY CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

POUR CHAQUE ENTITÃ‰, VÃ‰RIFIER:

TABLE LEVEL:
  [ ] TextColumn farmId prÃ©sent
  [ ] @override customConstraints contient FK farm_id
  [ ] FK pointe vers farms(id)
  [ ] FK a ON DELETE CASCADE

DAO LEVEL:
  [ ] Toutes les queries ont .where((t) => t.farmId.equals(farmId))
  [ ] Toutes les queries ont .where((t) => t.deletedAt.isNull())
  [ ] updateItem prend farmId en paramÃ¨tre
  [ ] softDelete prend farmId en paramÃ¨tre
  [ ] countByFarmId filtre farmId

REPOSITORY LEVEL:
  [ ] getAll(farmId) passe farmId au DAO
  [ ] getById(id, farmId) passe farmId au DAO
  [ ] create(item, farmId) force farmId dans companion
  [ ] update(item, farmId) force farmId dans companion
  [ ] delete(id, farmId) passe farmId au DAO
  [ ] Tous les appels DAO incluent farmId

RÃ‰SULTAT:
  âœ… Impossible pour user A d'accÃ©der data farm B
  âœ… Chaque opÃ©ration filtre farmId
  âœ… ForeignKey enforce au niveau DB
  âœ… Security en multi-couches (DAO + Repository + DB)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
13. VALIDATION FINALE CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

APRÃˆS AVOIR CODÃ‰ TOUTES LES 11 ENTITÃ‰S:

COMPILATION:
  [ ] flutter pub run build_runner build --delete-conflicting-outputs (0 erreurs)
  [ ] flutter analyze (0 erreurs)
  [ ] flutter run (app dÃ©marre)

RUNTIME:
  [ ] App ne crash pas au dÃ©marrage
  [ ] Pas de "Could not find provider" errors
  [ ] Pas de "Failed assertion" errors
  [ ] Pas de "Null check operator used" errors

FUNCTIONALITY (si UI implÃ©mentÃ©e):
  [ ] CRUD fonctionne pour chaque entitÃ©
  [ ] Logs s'affichent correctement
  [ ] Multi-farm isolation OK (si testable)

LOGGING:
  [ ] Chaque create: âœ… [ENTITY] crÃ©Ã©
  [ ] Chaque update: âœ… [ENTITY] mis Ã  jour
  [ ] Chaque delete: âœ… [ENTITY] supprimÃ©
  [ ] Erreurs: âš ï¸ ERREUR ... (lisible)

BONUS (Nice to have):
  [ ] Performance: Queries en <100ms
  [ ] Pas de memory leaks
  [ ] Pas de dangling connections

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
14. ORDRE EXACT Ã€ SUIVRE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

JOUR 1 - TIER 1 (Matin/AprÃ¨s-midi):

1. Lire ce document EN ENTIER (20 min)
2. TREATMENTS (24 min)
   - Code Table
   - Code DAO
   - Code Repository
   - Build runner
3. VACCINATIONS (24 min)
4. WEIGHTS (24 min)
5. MOVEMENTS (24 min)
6. PAUSE (15 min)
7. flutter analyze TIER 1
8. flutter run (test)

Total: 2h 15 min

---

JOUR 1 - TIER 2 (AprÃ¨s-midi/Soir):

9. BATCHES (24 min)
10. LOTS (24 min - adapter FK vers Batches)
11. CAMPAIGNS (24 min)
12. MEDICAL_PRODUCTS (24 min)
13. PAUSE (15 min)
14. flutter analyze TIER 2
15. flutter run (test)

Total: 2h 15 min

---

JOUR 2 - TIER 3 (Matin):

16. BREEDS (19 min)
17. BREEDING (24 min - adapter FK vers Animals + Breeds)
18. DOCUMENTS (19 min)
19. flutter analyze TIER 3
20. flutter run (test complet)
21. flutter analyze (TOUT - final check)

Total: 1h 2 min

---

GRAND TOTAL RÃ‰EL: ~5.5 heures

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
END OF DOCUMENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROCHAINES Ã‰TAPES:
  1. Lire ce document entiÃ¨rement
  2. PrÃ©parer fichiers (copy-paste templates)
  3. Coder Tier 1 + build runner
  4. Coder Tier 2 + build runner
  5. Coder Tier 3 + build runner
  6. Final analysis + flutter run
  7. âœ… PHASE 1B COMPLÃˆTE POUR TOUTES LES ENTITÃ‰S!

BON COURAGE! ğŸš€


A ajouter avant chaque demande :
Pour app_strings etÂ strings_fr, donne moi seulement les string Ã  ajouter
Pas de Mock, nous sommes Ã  100% DB.
Demande moi les fichiers nÃ©cessaires pour faire votre travail.
Sur le document j'ai les phse XXXX et je veux faire la phase YYYYY